import glob
import json
import os
from pathlib import Path

msg = 'Checkpoint 5: snakefile command recieved - Chewbaca analysis \n'
sys.stderr.write(msg)

# proposed changes
"""
before the snakefile
1. ahead of the snakefile, check if the genome exists inside the tsv file
1.5 edit the perl script to ADD path to back end copy of the master TSV for that species to the config
2. if not, bring the genome to the staging dir
in the snakefile:
3. run the inital allele call 
4. pull the existing genome profiles and header (rows from the master table)
5. join the two tables
6. chewbacca remove genes
7. chewbacca extract cgmlst 95%
7.5 do we need to rerun the allele call for the INF values?
8. chewbaca do the allele call evaulation
"""




current_directory = os.getcwd()
# Load the JSON data
with open('{}/config.json'.format(current_directory)) as f:
    data = json.load(f)
clean_fasta_dir = data["clean_data_dir"]
work_dir = data["work_data_dir"]
output_dir = data["output_data_dir"]
schema_path = os.path.join(data["schema_location"], data["params"]["input_schema_selection"])
master_TSV = data["master_tsv"]
# check if you need all of these?
processed_genome_ids = data["processed_genome_ids"]
unprocessed_genome_ids = data["unprocessed_genome_ids"]
genome_group_name = data["params"]["input_genome_group"].split("/")[-1]

processed_genomes = Path(processed_genome_ids)
unprocessed_genomes = Path(unprocessed_genome_ids)


# ADD REPORT OPTION FOR EVERY CASE
if unprocessed_genomes.stat().st_size == 0 and processed_genomes.stat() !=0:
    print("All old genomes!")
    rule_all_list = [        
        # report on hold for now 
        # "{}/allelecall_evaulation_complete.txt".format(work_dir),
        "{}/extract_cg_mlst/cgMLSTschema95.txt".format(output_dir),
        "{}/{}_cluster_result_cgMLSTv1.npz".format(output_dir, genome_group_name),
        "{}/{}_distance.phylip".format(output_dir, genome_group_name)
    ]
    # genomes pulled from API ahead of snakefile are the only genomes
    final_allele_result = "{}/precomputed_allele_results.tsv".format(work_dir)
    allele_call_complete_touchpoint = "{}/precomputed_allele_results.tsv".format(work_dir)
    # report directory on hold for now 
    allele_call_input_dir = ""
elif processed_genomes.stat().st_size == 0 and unprocessed_genomes.stat() !=0:
    print("All new genomes")
    rule_all_list = [
        "{}/clean_fastas_complete.txt".format(work_dir),
        "{}/new_genomes_allele_call_complete.txt".format(work_dir),
        "{}/extract_cg_mlst/cgMLSTschema95.txt".format(output_dir),
        "{}/allelecall_evaulation_complete.txt".format(work_dir),
        "{}/allele_call_evaulator/allelecall_report.html".format(output_dir),
        "{}/{}_cluster_result_cgMLSTv1.npz".format(output_dir, genome_group_name),
        "{}/{}_distance.phylip".format(output_dir, genome_group_name)
    ]
    final_allele_result = "{}/new_genomes_allele_call/results_alleles.tsv".format(work_dir)
    allele_call_input_dir = "{}/new_genomes_allele_call/".format(work_dir)
    allele_call_complete_touchpoint = "{}/new_genomes_allele_call_complete.txt".format(work_dir)
else:
    print("Some genomes are processed and some are unprocessed. We need to join them.")
    rule_all_list = [
        "{}/clean_fastas_complete.txt".format(work_dir),
        "{}/new_genomes_allele_call_complete.txt".format(work_dir),
        # "{}/joined_allele/joined_allele_results.tsv".format(work_dir),
        "{}/extract_cg_mlst/cgMLSTschema95.txt".format(output_dir),
        # report directory on hold for now 
        # "{}/allelecall_evaulation_complete.txt".format(work_dir),
        "{}/{}_cluster_result_cgMLSTv1.npz".format(output_dir, genome_group_name),
        "{}/{}_distance.phylip".format(output_dir, genome_group_name)
        ]
    # only the genome groups
    allele_call_complete_touchpoint = "{}/genome_group_results.tsv".format(work_dir),
    final_allele_result = "{}/genome_group_results.tsv".format(work_dir)
    # report directory on hold for now - this is only the genome group
    allele_call_input_dir = ""

    # make sure the other steps use this 
    #genome_group_specific_existing_allele_results = "{}/genome_group_results.tsv".format(work_dir),

rule all:
    input:
        rule_all_list

rule prep_fastas_for_chewbbaca:
    input:
        config = '{}/config.json'.format(current_directory)
    output:
        touchpoint = "{}/clean_fastas_complete.txt".format(work_dir)
    shell:
        """
        core-genome-mlst-utils clean-fasta-filenames \
            {input.config}

        touch {output.touchpoint}
        """


rule run_new_genomes_allele_call:
    input:
        touchpoint = "{}/clean_fastas_complete.txt".format(work_dir)
    params:
        allele_call_out = "{}/new_genomes_allele_call/".format(work_dir),
        new_allele_calls = directory("{}/new_genomes_allele_call/result_alleles.tsv".format(work_dir)),
        clean_fasta_dir_ = clean_fasta_dir,
        schema_dir = schema_path,
    output:
        touchpoint = "{}/new_genomes_allele_call_complete.txt".format(work_dir),
    shell:
        """
        chewBBACA.py AlleleCall \
            --input-files {params.clean_fasta_dir_} \
            --schema-directory {params.schema_dir} \
            --output-directory {params.allele_call_out} \
            --cpu 4 \
            --output-unclassified \
            --output-missing \
            --output-novel \
            --no-inferred
        
        touch {output.touchpoint}
        """


rule join_new_and_existing_allele_call_results:
    input:
        touchpoint = "{}/new_genomes_allele_call_complete.txt".format(work_dir),
        pre_processed_from_api = "{}/precomputed_allele_results.tsv".format(work_dir),
        processed_ids = processed_genome_ids,
        unprocessed_ids = unprocessed_genome_ids
    params:
       new_genomes_allele_call_results = "{}/new_genomes_allele_call/results_alleles.tsv".format(work_dir),
    output:
        genome_group_specific_existing_allele_results = "{}/genome_group_results.tsv".format(work_dir),
    shell:
        """
        # 1 join all alleles in the genome group
        chewBBACA.py JoinProfiles \
            -p {params.new_genomes_allele_call_results} {input.pre_processed_from_api} \
            -o {output.genome_group_specific_existing_allele_results}
        """


rule extract_cgMLST:
    input:
        allele_call_complete_touchpoint
    params:
        extract_cgmlst_dir = directory("{}/extract_cg_mlst/".format(output_dir)),
        final_allele_results = final_allele_result
    output:
        extract_cgmlst_out = "{}/extract_cg_mlst/presence_absence.tsv".format(output_dir),
        loci_list = "{}/extract_cg_mlst/cgMLSTschema95.txt".format(output_dir)
    shell:
        """
        mkdir -p {params.extract_cgmlst_dir}

        chewBBACA.py ExtractCgMLST \
            --input-file {params.final_allele_results} \
            --output-directory {params.extract_cgmlst_dir}
        """

rule run_allele_call_evaluator:
    input:
        allele_call_complete_touchpoint
    params:
        schema_dir = schema_path,
        allele_call_input_dir_ = allele_call_input_dir,
        #allele_call_input_dir = directory("{}/joined_results_allele_call/".format(work_dir)),
        allele_evaulator_work = directory("{}/allele_call_evaulator".format(work_dir)),
        allele_evaulator_out = directory("{}/allele_call_evaulator".format(output_dir)),
    output:
        allele_call_report = "{}/allele_call_evaulator/allelecall_report.html".format(output_dir),
        touchpoint = "{}/allelecall_evaulation_complete.txt".format(work_dir)
    shell:
        """
        chewBBACA.py AlleleCallEvaluator \
            --input-files {params.allele_call_input_dir_} \
            --schema-directory {params.schema_dir} \
            --output-directory {params.allele_evaulator_work} \
            --cpu 4

        cp {params.allele_evaulator_work} {params.allele_evaulator_out}
        touch {output.touchpoint}
        """

rule run_local_clustering:
    input:
        # new_genomes_allele_call_results = "{}/new_genomes_allele_call/results_alleles.tsv".format(work_dir),
        master_TSV = data["master_tsv"],
        reference_clusters = data["precomputed_clusters_path"],
        allele_call_complete_touchpoint = allele_call_complete_touchpoint
    params:
        clean_master_joined = "{}/master_joined_allele_results_clean.tsv".format(work_dir),
        tmp_out_name = "{}/{}_cluster_result_cgMLSTv1".format(work_dir, genome_group_name),
        zipped_cluster_result = "{}/{}_cluster_result_cgMLSTv1.HierCC.gz".format(work_dir, genome_group_name),
        unzipped_cluster_result = "{}/{}_cluster_result_cgMLSTv1.HierCC".format(work_dir, genome_group_name),
        tmp_npz = "{}/{}_cluster_result_cgMLSTv1.npz".format(work_dir, genome_group_name),
        final_allele_results = final_allele_result,
    output:
        master_joined = "{}/master_joined_allele_results.tsv".format(work_dir),
        cluster_result = "{}/{}_cluster_result_cgMLSTv1.HierCC".format(output_dir, genome_group_name),
        npz = "{}/{}_cluster_result_cgMLSTv1.npz".format(output_dir, genome_group_name),
        final_out = "{}/result_alleles.tsv".format(output_dir)

    shell:
        """
        # merge the new allele call results with the existing allele call results        
        chewBBACA.py JoinProfiles \
            -p {input.master_TSV} \
            {params.final_allele_results} \
            -o {output.master_joined}

        # run prep script for clustering
        core-genome-mlst-utils clean-allelic-profile {output.master_joined}

        # cluster using precomputed clusters
        pHierCC \
            --profile {params.clean_master_joined} \
            --output {params.tmp_out_name} \
            --append {input.reference_clusters}
        
        gunzip {params.zipped_cluster_result}

        # copy unzipped cluster to output 
        cp {params.unzipped_cluster_result} {output.cluster_result}

        # copy npz from work to output
        cp {params.tmp_npz} {output.npz}
        
        # copy final allele call result to output
        cp {params.final_allele_results} {output.final_out}
        """
    
rule run_grapetree_cli:
    input:
        allele_call_complete_touchpoint = allele_call_complete_touchpoint,
        metadata = "{}/genome_metadata.json".format(current_directory)
    params:
        all_call_input = final_allele_result,
        tmp_MSTreeV2 = "{}/{}_MSTreeV2.svg".format(output_dir, genome_group_name),
        work_dir = directory(work_dir)
    output:
        MSTreeV2 = "{}/{}_MSTreeV2.nwk".format(output_dir, genome_group_name),
        MSTreeV2_svg = "{}/cgmlst_tree.svg".format(work_dir, genome_group_name),
        distance = "{}/{}_distance.phylip".format(output_dir, genome_group_name),
        output_report = "{}/cgMLST_Report.html".format(output_dir)
    shell:
        """
        grapetree -p {params.all_call_input} -m distance > {output.distance}

        grapetree -p {params.all_call_input} -m MSTreeV2 > {output.MSTreeV2}

        p3x-tree-to-svg {output.MSTreeV2}
        
        mv {params.tmp_MSTreeV2} {output.MSTreeV2_svg}

        core-genome-mlst-utils write-html-report {params.all_call_input} \
            {input.metadata} {output.output_report} --svg-dir {params.work_dir}
        """

# rule filtered_remove_empty_dir:
#     input:
#         filtered_touchpoint = "{}/_allele_call_evaulation_complete.txt".format(work_dir)
#     params:
#         empty_dir = "{}/filtered_schema_allele_call/dummy_dir".format(work_dir),
#         work_dir = directory("{}/filtered_dd".format(work_dir))
#     output:
#         filtered_move_empty_dir_touchpoint = "{}/filtered_allele_call_touchpoint.txt".format(work_dir),
#     shell:
#         """
#         mkdir -p {params.work_dir}
        
#         [ -d "{params.empty_dir}" ] && mv {params.empty_dir} {params.work_dir}/

#         touch {output.filtered_move_empty_dir_touchpoint}
#         """

# rule full_remove_empty_dir:
#     input:
#         full_touchpoint = "{}/new_genomes_allele_call_complete.txt".format(work_dir)
#     params:
#         empty_dir = "{}/new_genomes_allele_call/dummy_dir".format(work_dir),
#         work_dir = directory("{}/full_dd".format(work_dir))
#     output:
#         full_move_empty_dir_touchpoint = "{}/full_allele_call_touchpoint.txt".format(work_dir),
#     shell:
#         """
#         mkdir -p {params.work_dir}

#         [ -d "{params.empty_dir}" ] && mv {params.empty_dir} {params.work_dir}/

#         touch {output.full_move_empty_dir_touchpoint}
#         """

